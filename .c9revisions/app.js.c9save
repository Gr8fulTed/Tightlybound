{"ts":1361677043815,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":["jacksonroberts25@gmail.com","david_patch98@hotmail.com","jspencer233@bigpond.com"],"silentsave":false,"ts":1361677177498,"patch":[[{"diffs":[[1,"var express = require('express')\n  , passport = require('passport')\n  , LocalStrategy = require('passport-local').Strategy\n  , mongodb = require('mongodb')\n  , mongoose = require('mongoose')\n  , bcrypt = require('bcrypt')\n  , SALT_WORK_FACTOR = 10;\n  \nmongoose.connect('localhost', 'test');\nvar db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'connection error:'));\ndb.once('open', function callback() {\n  console.log('Connected to DB');\n});\n\n// User Schema\nvar userSchema = mongoose.Schema({\n  username: { type: String, required: true, unique: true },\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true},\n  accessToken: { type: String } // Used for Remember Me\n});\n\n// Bcrypt middleware\nuserSchema.pre('save', function(next) {\n    var user = this;\n\n\tif(!user.isModified('password')) return next();\n\n\tbcrypt.genSalt(SALT_WORK_FACTOR, function(err, salt) {\n\t\tif(err) return next(err);\n\n\t\tbcrypt.hash(user.password, salt, function(err, hash) {\n\t\t\tif(err) return next(err);\n\t\t\tuser.password = hash;\n\t\t\tnext();\n\t\t});\n\t});\n});\n\n// Password verification\nuserSchema.methods.comparePassword = function(candidatePassword, cb) {\n\tbcrypt.compare(candidatePassword, this.password, function(err, isMatch) {\n\t\tif(err) return cb(err);\n\t\tcb(null, isMatch);\n\t});\n};\n\n// Remember Me implementation helper method\nuserSchema.methods.generateRandomToken = function () {\n  var user = this,\n      chars = \"_!abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\",\n      token = new Date().getTime() + '_';\n  for ( var x = 0; x < 16; x++ ) {\n    var i = Math.floor( Math.random() * 62 );\n    token += chars.charAt( i );\n  }\n  return token;\n};\n\n// Seed a user\nvar User = mongoose.model('User', userSchema);\nvar usr = new User({ username: 'bob', email: 'bob@example.com', password: 'secret' });\nusr.save(function(err) {\n  if(err) {\n    console.log(err);\n  } else {\n    console.log('user: ' + usr.username + \" saved.\");\n  }\n});\n\n\n// Passport session setup.\n//   To support persistent login sessions, Passport needs to be able to\n//   serialize users into and deserialize users out of the session.  Typically,\n//   this will be as simple as storing the user ID when serializing, and finding\n//   the user by ID when deserializing.\n//\n//   Both serializer and deserializer edited for Remember Me functionality\npassport.serializeUser(function(user, done) {\n  var createAccessToken = function () {\n    var token = user.generateRandomToken();\n    User.findOne( { accessToken: token }, function (err, existingUser) {\n      if (err) { return done( err ); }\n      if (existingUser) {\n        createAccessToken(); // Run the function again - the token has to be unique!\n      } else {\n        user.set('accessToken', token);\n        user.save( function (err) {\n          if (err) return done(err);\n          return done(null, user.get('accessToken'));\n        })\n      }\n    });\n  };\n\n  if ( user._id ) {\n    createAccessToken();\n  }\n});\n\npassport.deserializeUser(function(token, done) {\n  User.findOne( {accessToken: token } , function (err, user) {\n    done(err, user);\n  });\n});\n\n\n// Use the LocalStrategy within Passport.\n//   Strategies in passport require a `verify` function, which accept\n//   credentials (in this case, a username and password), and invoke a callback\n//   with a user object.  In the real world, this would query a database;\n//   however, in this example we are using a baked-in set of users.\npassport.use(new LocalStrategy(function(username, password, done) {\n  User.findOne({ username: username }, function(err, user) {\n    if (err) { return done(err); }\n    if (!user) { return done(null, false, { message: 'Unknown user ' + username }); }\n    user.comparePassword(password, function(err, isMatch) {\n      if (err) return done(err);\n      if(isMatch) {\n        return done(null, user);\n      } else {\n        return done(null, false, { message: 'Invalid password' });\n      }\n    });\n  });\n}));\n\n\nvar app = express();\n\n// configure Express\napp.configure(function() {\n  app.set('views', __dirname + '/views');\n  app.set('view engine', 'ejs');\n  app.engine('ejs', require('ejs-locals'));\n  app.use(express.logger());\n  app.use(express.cookieParser());\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  app.use(express.session({ secret: 'keyboard cat' })); // CHANGE THIS SECRET!\n  // Remember Me middleware\n  app.use( function (req, res, next) {\n    if ( req.method == 'POST' && req.url == '/login' ) {\n      if ( req.body.rememberme ) {\n        req.session.cookie.maxAge = 2592000000; // 30*24*60*60*1000 Rememeber 'me' for 30 days\n      } else {\n        req.session.cookie.expires = false;\n      }\n    }\n    next();\n  });\n  // Initialize Passport!  Also use passport.session() middleware, to support\n  // persistent login sessions (recommended).\n  app.use(passport.initialize());\n  app.use(passport.session());\n  app.use(app.router);\n  app.use(express.static(__dirname + '/../../public'));\n});\n\n\napp.get('/', function(req, res){\n  res.render('index', { user: req.user });\n});\n\napp.get('/account', ensureAuthenticated, function(req, res){\n  res.render('account', { user: req.user });\n});\n\napp.get('/login', function(req, res){\n  res.render('login', { user: req.user, message: req.session.messages });\n});\n\n// POST /login\n//   Use passport.authenticate() as route middleware to authenticate the\n//   request.  If authentication fails, the user will be redirected back to the\n//   login page.  Otherwise, the primary route function function will be called,\n//   which, in this example, will redirect the user to the home page.\n//\n//   curl -v -d \"username=bob&password=secret\" http://127.0.0.1:3000/login\n//   \n/***** This version has a problem with flash messages\napp.post('/login', \n  passport.authenticate('local', { failureRedirect: '/login', failureFlash: true }),\n  function(req, res) {\n    res.redirect('/');\n  });\n*/\n  \n// POST /login\n//   This is an alternative implementation that uses a custom callback to\n//   acheive the same functionality.\napp.post('/login', function(req, res, next) {\n  passport.authenticate('local', function(err, user, info) {\n    if (err) { return next(err) }\n    if (!user) {\n      req.session.messages =  [info.message];\n      return res.redirect('/login')\n    }\n    req.logIn(user, function(err) {\n      if (err) { return next(err); }\n      return res.redirect('/');\n    });\n  })(req, res, next);\n});\n\napp.get('/logout', function(req, res){\n  req.logout();\n  res.redirect('/');\n});\n\napp.listen(3000, function() {\n  console.log('Express server listening on port 3000');\n});\n\n\n// Simple route middleware to ensure user is authenticated.\n//   Use this route middleware on any resource that needs to be protected.  If\n//   the request is authenticated (typically via a persistent login session),\n//   the request will proceed.  Otherwise, the user will be redirected to the\n//   login page.\nfunction ensureAuthenticated(req, res, next) {\n  if (req.isAuthenticated()) { return next(); }\n  res.redirect('/login')\n}"]],"start1":0,"start2":0,"length1":0,"length2":7036}]],"length":7036,"saved":false}
